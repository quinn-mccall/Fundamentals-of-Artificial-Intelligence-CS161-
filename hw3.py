##############
# Homework 3 #
##############
# Quincy McCall - 505 894 780

# Collaborators:
# Brian Yang - we discussed why both of our programs could be getting stuck waiting in s6 during OH


###################
# Read This First #
###################


# All functions that you need to modify are marked with 'EXERCISE' in their header comments.
# Do not modify astar.py
# This file also contains many helper functions. You may call any of them in your functions.


# Due to the memory limitation, the A* algorithm may crash on some hard sokoban problems if too many
# nodes are generated. Improving the quality of the heuristic will mitigate
# this problem, as it will allow A* to solve hard problems with fewer node expansions.


# Remember that most functions are not graded on efficiency (only correctness).
# Efficiency can only influence your heuristic performance in the competition (which will affect your score).


# Load the astar.py and do not modify it.
import astar
# Load the numpy package and the state is represented as a numpy array during this homework.
import numpy as np
import time 


# a_star perform the A* algorithm with the start_state (numpy array), goal_test (function), successors (function) and
# heuristic (function). a_star prints the solution from start_state to goal_state (path), calculates the number of
# generated nodes (node_generated) and expanded nodes (node_expanded), and the solution depth (len(path)-1). a_star
# also provides the following functions for printing states and moves: prettyMoves(path): Translate the solution to a
# list of moves printlists(path): Visualize the solution and Print a list of states
def a_star(start_state, goal_test, successors, heuristic):
    goal_node, node_generated, node_expanded = astar.a_star_search(start_state, goal_test, successors, heuristic)
    if goal_node:
        node = goal_node
        path = [node.state1]
        while node.parent:
            node = node.parent
            path.append(node.state1)
        path.reverse()

        # print('My path:{}'.format(path))
        # print(prettyMoves(path))
        # printlists(path)
        print('Nodes Generated by A*: {}'.format(node_generated))
        print('Nodes Expanded by A*: {}'.format(node_expanded))
        print('Solution Depth: {}'.format(len(path) - 1))
    else:
        print('no solution found')


# A shortcut function
# Transform the input state to numpy array. For other functions, the state s is presented as a numpy array.
# Goal-test and next-states stay the same throughout the assignment
# You can just call sokoban(init-state, heuristic function) to test the result
def sokoban(s, h):
    return a_star(np.array(s), goal_test, next_states, h)


# Define some global variables
blank = 0
wall = 1
box = 2
keeper = 3
star = 4
boxstar = 5
keeperstar = 6


# Some helper functions for checking the content of a square
def isBlank(v):
    return (v == blank)


def isWall(v):
    return (v == wall)


def isBox(v):
    return (v == box)


def isKeeper(v):
    return (v == keeper)


def isStar(v):
    return (v == star)


def isBoxstar(v):
    return (v == boxstar)


def isKeeperstar(v):
    return (v == keeperstar)


# Help function for get KeeperPosition
# Given state s (numpy array), return the position of the keeper by row, col
# The top row is the zeroth row
# The first (right) column is the zeroth column
def getKeeperPosition(s):
    row = s.shape[0]
    col = s.shape[1]
    for i in range(row):
        for j in range(col):
            if (isKeeper(s[i, j]) or isKeeperstar(s[i, j])):
                return i, j


# For input list s_list, remove all None element
# For example, if s_list = [1, 2, None, 3], returns [1, 2, 3]
def cleanUpList(s_list):
    clean = []
    for state in s_list:
        if state is not None:
            clean.append(state)
    return clean


# EXERCISE: Modify this function to return Ture
# if and only if s (numpy array) is a goal state of a Sokoban game.
# (no box is on a non-goal square)
# Remember, the number of goal can be larger than the number of box.
# Currently, it always returns False. If A* is called with
# this function as the goal testing function, A* will never
# terminate until the whole search space is exhausted.

def goal_test(s):
    
    # a goal state is only valid when there are no boxes on a non-goal square, so 
    # by checking if there are any squares labeled as boxes, we can tell if it is a goal state
    # because if all boxes are on the goal, then they should be labeled boxstar -- can check this by 
    # checking each square of our board to see if it is a box
     count = np.count_nonzero(s == box)
     if count != 0:
         return False
     return True

# EXERCISE: Modify this function to return the list of
# successor states of s (numpy array).
#
# This is the top-level next-states (successor) function.
# Some skeleton code is provided below.
# You may delete them totally, depending on your approach.
# 
# If you want to use it, you will need to set 'result' to be 
# the set of states after moving the keeper in each of the 4 directions.
#
# You can define the function try-move and decide how to represent UP,DOWN,LEFT,RIGHT.
# Any None result in the list can be removed by cleanUpList.
#
# When generated the successors states, you may need to copy the current state s (numpy array).
# A shallow copy (e.g, direcly set s1 = s) constructs a new compound object and then inserts references 
# into it to the objects found in the original. In this case, any change in the numpy array s1 will also affect
# the original array s. Thus, you may need a deep copy (e.g, s1 = np.copy(s)) to construct an indepedent array.
def get_square(s, r, c):
    # takes in a state, row, and column, and returns the value at the square
    # if the direction is out of bounds it returns a wall 
    if r < 0 or r >= s.shape[0] or c < 0 or c >= s.shape[1]:
        return wall
    return s[r, c]

def set_square(s, r, c, v):
    # takes in a state copy, row, column, and new value, v, and returns a new state, 
    # where the value at the row and column is set to v
    # returns the modified state copy without modifying the original input 
    if 0 <= r < s.shape[0] and 0 <= c < s.shape[1]:
        s[r, c] = v
        


def try_move_keeper(s, D):
    
    # Takes in the state, and the direction. Direction is defined as a tuple that has the direction
    # denoted as any UP, DOWN, LEFT, or RIGHT and each tuple has a corresponding list that contains 
    # row and column that the direction wants to move to in respect to the keeper
    # based on these two inputs this function goes through a series of logic to determine what 
    # moves are possible in this direction and then returns the a modified state copy to avoid altering
    # the original state 
    
    state_copy = np.copy(s)
    direction = D[0]
    row, col = D[1][0], D[1][1]
    value = get_square(state_copy, row, col)
    if direction == "UP": # row + 1, col
        if value == wall:
            return None
        elif value == box:
            if get_square(state_copy, row + 1, col) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row + 1, col) == star:
                set_square(state_copy, row + 1, col, boxstar)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row - 1, col, blank)
            elif get_square(state_copy, row + 1, col) == blank:
                set_square(state_copy, row + 1, col, box)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row - 1, col, blank)
        elif value == blank:
            set_square(state_copy, row, col, keeper)
            set_square(state_copy, row - 1, col, blank)
        elif value == star:
            set_square(state_copy, row, col, keeperstar)
            set_square(state_copy, row - 1, col, blank)
        elif value == boxstar:
            if get_square(state_copy, row + 1, col) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row + 1, col) == star:
                set_square(state_copy, row + 1, col, boxstar)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row - 1, col, blank)
            elif get_square(state_copy, row + 1, col) == blank:
                set_square(state_copy, row + 1, col, box)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row - 1, col, blank)
                
    
    if direction == "DOWN": # row - 1, col
        if value == wall:
            return None
        elif value == box:
            if get_square(state_copy, row - 1, col) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row - 1, col) == star:
                set_square(state_copy, row - 1, col, boxstar)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row + 1, col, blank)
            elif get_square(state_copy, row - 1, col) == blank:
                set_square(state_copy, row - 1, col, box)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row + 1, col, blank)
        elif value == blank:
            set_square(state_copy, row, col, keeper)
            set_square(state_copy, row + 1, col, blank)
        elif value == star:
            set_square(state_copy, row, col, keeperstar)
            set_square(state_copy, row + 1, col, blank)
        elif value == boxstar:
            if get_square(state_copy, row - 1, col) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row - 1, col) == star:
                set_square(state_copy, row - 1, col, boxstar)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row + 1, col, blank)
            elif get_square(state_copy, row - 1, col) == blank:
                set_square(state_copy, row - 1, col, box)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row + 1, col, blank)

    if direction == "RIGHT": # row, col + 1
        if value == wall:
            return None
        elif value == box:
            if get_square(state_copy, row, col + 1) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row, col + 1) == star:
                set_square(state_copy, row, col + 1, boxstar)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row, col - 1, blank)
            elif get_square(state_copy, row, col + 1) == blank:
                set_square(state_copy, row, col + 1, box)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row, col - 1, blank)
        elif value == blank:
            set_square(state_copy, row, col, keeper)
            set_square(state_copy, row, col - 1, blank)
        elif value == star:
            set_square(state_copy, row, col, keeperstar)
            set_square(state_copy, row, col - 1, blank)
        elif value == boxstar:
            if get_square(state_copy, row, col + 1)in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row, col + 1) == star:
                set_square(state_copy, row, col + 1, boxstar)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row, col - 1, blank)
            elif get_square(state_copy, row, col + 1) == blank:
                set_square(state_copy, row, col + 1, box)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row, col - 1, blank)
                
                
    if direction == "LEFT": # row, col - 1
        if value == wall:
            return None
        elif value == box:
            if get_square(state_copy, row, col - 1) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row, col - 1) == star:
                set_square(state_copy, row, col - 1, boxstar)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row, col + 1, blank)
            elif get_square(state_copy, row, col - 1) == blank:
                set_square(state_copy, row, col - 1, box)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row, col + 1, blank)
        elif value == blank:
            set_square(state_copy, row, col, keeper)
            set_square(state_copy, row, col + 1, blank)
        elif value == star:
            set_square(state_copy, row, col, keeperstar)
            set_square(state_copy, row, col + 1, blank)
        elif value == boxstar:
            if get_square(state_copy, row, col - 1) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row, col - 1) == star:
                set_square(state_copy, row, col - 1, boxstar)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row, col + 1, blank)
            elif get_square(state_copy, row, col - 1) == blank:
                set_square(state_copy, row, col - 1, box)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row, col + 1, blank)
    return state_copy

def try_move_keeperstar(s, D):
    
    # Takes in the state, and the direction. Direction is defined as a tuple that has the direction
    # denoted as any UP, DOWN, LEFT, or RIGHT and each tuple has a corresponding list that contains 
    # row and column that the direction wants to move to in respect to the keeperstar
    # based on these two inputs this function goes through a series of logic to determine what 
    # moves are possible in this direction and then returns the new state copy to avoid altering
    # the original state 
    
    state_copy = np.copy(s)
    direction = D[0]
    row, col = D[1][0], D[1][1]
    value = get_square(state_copy, row, col)
    if direction == "UP": # row + 1, col
        if value == wall:
            return None
        elif value == box:
            if get_square(state_copy, row + 1, col) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row + 1, col) == star:
                set_square(state_copy, row + 1, col, boxstar)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row - 1, col, star)
            elif get_square(state_copy, row + 1, col) == blank:
                set_square(state_copy, row + 1, col, box)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row - 1, col, star)
        elif value == blank:
            set_square(state_copy, row, col, keeper)
            set_square(state_copy, row - 1, col, star)
        elif value == star:
            set_square(state_copy, row, col, keeperstar)
            set_square(state_copy, row - 1, col, star)
        elif value == boxstar:
            if get_square(state_copy, row + 1, col) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row + 1, col) == star:
                set_square(state_copy, row + 1, col, boxstar)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row - 1, col, star)
            elif get_square(state_copy, row + 1, col) == blank:
                set_square(state_copy, row + 1, col, box)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row - 1, col, star)
                
    
    if direction == "DOWN": # row - 1, col
        if value == wall:
            return None
        elif value == box:
            if get_square(state_copy, row - 1, col) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row - 1, col) == star:
                set_square(state_copy, row - 1, col, boxstar)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row + 1, col, star)
            elif get_square(state_copy, row - 1, col) == blank:
                set_square(state_copy, row - 1, col, box)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row + 1, col, star)
        elif value == blank:
            set_square(state_copy, row, col, keeper)
            set_square(state_copy, row + 1, col, star)
        elif value == star:
            set_square(state_copy, row, col, keeperstar)
            set_square(state_copy, row + 1, col, star)
        elif value == boxstar:
            if get_square(state_copy, row - 1, col) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row - 1, col) == star:
                set_square(state_copy, row - 1, col, boxstar)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row + 1, col, star)
            elif get_square(state_copy, row - 1, col) == blank:
                set_square(state_copy, row - 1, col, box)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row + 1, col, star)

    if direction == "RIGHT": # row, col + 1
        if value == wall:
            return None
        elif value == box:
            if get_square(state_copy, row, col + 1) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row, col + 1) == star:
                set_square(state_copy, row, col + 1, boxstar)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row, col - 1, star)
            elif get_square(state_copy, row, col + 1) == blank:
                set_square(state_copy, row, col + 1, box)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row, col - 1, star)
        elif value == blank:
            set_square(state_copy, row, col, keeper)
            set_square(state_copy, row, col - 1, star)
        elif value == star:
            set_square(state_copy, row, col, keeperstar)
            set_square(state_copy, row, col - 1, star)
        elif value == boxstar:
            if get_square(state_copy, row, col + 1)in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row, col + 1) == star:
                set_square(state_copy, row, col + 1, boxstar)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row, col - 1, star)
            elif get_square(state_copy, row, col + 1) == blank:
                set_square(state_copy, row, col + 1, box)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row, col - 1, star)
                
                
    if direction == "LEFT": # row, col - 1
        if value == wall:
            return None
        elif value == box:
            if get_square(state_copy, row, col - 1) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row, col - 1) == star:
                set_square(state_copy, row, col - 1, boxstar)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row, col + 1, star)
            elif get_square(state_copy, row, col - 1) == blank:
                set_square(state_copy, row, col - 1, box)
                set_square(state_copy, row, col, keeper)
                set_square(state_copy, row, col + 1, star)
        elif value == blank:
            set_square(state_copy, row, col, keeper)
            set_square(state_copy, row, col + 1, star)
        elif value == star:
            set_square(state_copy, row, col, keeperstar)
            set_square(state_copy, row, col + 1, star)
        elif value == boxstar:
            if get_square(state_copy, row, col - 1) in [wall, box, boxstar]:
                return None
            elif get_square(state_copy, row, col - 1) == star:
                set_square(state_copy, row, col - 1, boxstar)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row, col + 1, star)
            elif get_square(state_copy, row, col - 1) == blank:
                set_square(state_copy, row, col - 1, box)
                set_square(state_copy, row, col, keeperstar)
                set_square(state_copy, row, col + 1, star)
    return state_copy
        
    


def next_states(s):
    # this function takes in a state and calls the helper 
    # functions try_move_keeper and try_move_keeperstar
    # to get a list of the next possible states from state s
    row, col = getKeeperPosition(s)
    value = get_square(s, row, col)
    state_list = []
    directions = [("UP", [row + 1, col]), ("DOWN", [row - 1, col]),( "RIGHT", [row, col + 1]),  ("LEFT",[row , col - 1])]
    for direction in directions:
        # Call try_move with a fresh copy of the state each time
        if value == keeper:
            new_state = try_move_keeper(np.copy(s), direction)
        elif value == keeperstar:
            new_state = try_move_keeperstar(np.copy(s), direction)
        state_list.append(new_state)
    
    return cleanUpList(state_list)

# TEST NEXT STATES 

# s1 = np.array([[1, 1, 1, 1, 1],
#                [1, 0, 0, 4, 1],
#                [1, 0, 2, 0, 1],
#                [1, 0, 3, 0, 1],
#                [1, 0, 0, 0, 1],
#                [1, 1, 1, 1, 1]])

# s2 = np.array([[1, 1, 1, 1, 1],
#                [1, 0, 0, 4, 1],
#                [1, 0, 2, 3, 1],
#                [1, 0, 0, 0, 1],
#                [1, 0, 0, 0, 1],
#                [1, 1, 1, 1, 1]])

# print("s1",next_states(np.array(s1)))
# print("s2",next_states(np.array(s2)))

# s4 = [[1, 1, 1, 1, 1, 1, 1],
#       [0, 0, 0, 0, 0, 1, 4],
#       [0, 0, 0, 0, 0, 0, 0],
#       [0, 0, 1, 1, 1, 0, 0],
#       [0, 0, 1, 0, 0, 0, 0],
#       [0, 2, 1, 0, 0, 0, 0],
#       [0, 3, 1, 0, 0, 0, 0]]
# print("s4",next_states(np.array(s4)))

# s8 = [[1, 1, 1, 1, 1, 1],
#       [1, 4, 0, 0, 4, 1],
#       [1, 0, 2, 2, 0, 1],
#       [1, 2, 0, 1, 0, 1],
#       [1, 3, 0, 0, 4, 1],
#       [1, 1, 1, 1, 1, 1]]
# print("s8",next_states(np.array(s8)))




# EXERCISE: Modify this function to compute the trivial
# admissible heuristic.
def h0(s):
    # trivial heuristic, returns the constant 0
    return 0


# EXERCISE: Modify this function to compute the
# number of misplaced boxes in state s (numpy array).
def h1(s):
    # this heuristic counts the number of boxes that are not in their goal position.
    # this function implements the np.count_nonzero function because it is faster than
    # looping through the state array
    # this heuristic is admissable because it returns the count of the number of boxes not in a goal state
    # which is always less than or equal to the number of boxes that are not on their respective goals in 
    # the real solution
    # returns 0 when all boxes are on a goal which is a goal state
    return np.count_nonzero(s == box)
                


# EXERCISE: Change the name of this function to h<UID> where
# <UID> is your actual student ID number. Then, modify this 
# function to compute an admissible heuristic value of s. 
# For example, if my UID is 123456789, then I should change the function name to 'h123456789'
# This function will be tested in various hard examples.
# Objective: make A* solve problems as fast as possible.
def checkDeadlock(s, b):
    #this function is a helper function for my heuristic and it takes in the state and a box 
    # and checks if the box is stuck in a deadlock state, in a corner or a corner formed with another box
    up = get_square(s, b[0] + 1, b[1])
    down = get_square(s, b[0] - 1, b[1])
    left = get_square(s, b[0], b[1] - 1)
    right = get_square(s, b[0], b[1] + 1)
    if up == wall and right == wall or up == wall and left == wall:
        return np.inf
    if down == wall and right == wall or down == wall and left == wall:
        return np.inf
    if down == wall and left == box or down == wall and right == box:
        return np.inf
    if up == wall and left == box or up == wall and right == box:
        return np.inf
    return 0
    

def h505894780(s):
    # this heuristic should sum the manhattan distance of every box to its nearest goal
    # this heuristic relaxes the rules to assume there are no walls and will always be an underestimate 
    # of the actual distance because it counts distance of each box to the nearest goal, not the goal
    # the box will actually end up in, when all boxes are on a goal the heuristic returns 0 
    # which is correct because it is a goal state
    def man_distance(element1, element2):
        return abs(element1[0] - element2[0]) + abs(element1[1] - element2[1])
    boxes = np.argwhere((s == box))
    goals = np.argwhere((s == star) | (s == keeperstar) )
    total_distance = 0
    if boxes.size ==0:
        return 0
    goal_tuples = [tuple(g) for g in goals]
    for b in boxes:
        deadlock =checkDeadlock(s, b)
        if deadlock != 0:
            return deadlock
        min_distance = float('inf')
        box_tuple = tuple(b)
        for g in goal_tuples:
            distance = man_distance(box_tuple, g)
            if distance == 0:
                min_distance = 0
                break
            if distance < min_distance:
                min_distance = distance
        total_distance += min_distance
    return total_distance

# Some predefined problems with initial state s (array). Sokoban function will automatically transform it to numpy
# array. For other function, the state s is presented as a numpy array. You can just call sokoban(init-state,
# heuristic function) to test the result Each problem can be visualized by calling prettyMoves(path) and printlists(
# path) in a_star function
#
# Problems are roughly ordered by their difficulties.
# For most problems, we also provide 2 additional number per problem:
#    1) # of nodes expanded by A* using our next-states and h0 heuristic.
#    2) the depth of the optimal solution.
# These numbers are located at the comments of the problems. For example, the first problem below 
# was solved by 80 nodes expansion of A* and its optimal solution depth is 7.
# 
# Your implementation may not result in the same number of nodes expanded, but it should probably
# give something in the same ballpark. As for the solution depth, any admissible heuristic must 
# make A* return an optimal solution. So, the depths of the optimal solutions provided could be used
# for checking whether your heuristic is admissible.
#
# Warning: some problems toward the end are quite hard and could be impossible to solve without a good heuristic!


# [80,7]
s1 = [[1, 1, 1, 1, 1, 1],
      [1, 0, 3, 0, 0, 1],
      [1, 0, 2, 0, 0, 1],
      [1, 1, 0, 1, 1, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 0, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1]]

# [110,10],
s2 = [[1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 1],
      [1, 0, 0, 0, 0, 0, 1],
      [1, 0, 0, 2, 1, 4, 1],
      [1, 3, 0, 0, 1, 0, 1],
      [1, 1, 1, 1, 1, 1, 1]]

# [211,12],
s3 = [[1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 0, 0, 0, 2, 0, 3, 4, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [300,13],
s4 = [[1, 1, 1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0, 1, 4],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 1, 1, 1, 0, 0],
      [0, 0, 1, 0, 0, 0, 0],
      [0, 2, 1, 0, 0, 0, 0],
      [0, 3, 1, 0, 0, 0, 0]]

# [551,10],
s5 = [[1, 1, 1, 1, 1, 1],
      [1, 1, 0, 0, 1, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 4, 2, 2, 4, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 1, 3, 1, 1, 1],
      [1, 1, 1, 1, 1, 1]]

# [722,12],
s6 = [[1, 1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 4, 1],
      [1, 0, 0, 0, 2, 2, 3, 1],
      [1, 0, 0, 1, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1, 1, 1]]

# [1738,50],
s7 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [0, 0, 1, 1, 1, 1, 0, 0, 0, 3],
      [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
      [0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
      [0, 2, 1, 0, 0, 0, 0, 0, 1, 0],
      [0, 0, 1, 0, 0, 0, 0, 0, 1, 4]]

# [1763,22],
s8 = [[1, 1, 1, 1, 1, 1],
      [1, 4, 0, 0, 4, 1],
      [1, 0, 2, 2, 0, 1],
      [1, 2, 0, 1, 0, 1],
      [1, 3, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1]]

# [1806,41],
s9 = [[1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 0, 0, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 2, 0, 1],
      [1, 0, 1, 0, 0, 1, 2, 0, 1],
      [1, 0, 4, 0, 4, 1, 3, 0, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [10082,51],
s10 = [[1, 1, 1, 1, 1, 0, 0],
       [1, 0, 0, 0, 1, 1, 0],
       [1, 3, 2, 0, 0, 1, 1],
       [1, 1, 0, 2, 0, 0, 1],
       [0, 1, 1, 0, 2, 0, 1],
       [0, 0, 1, 1, 0, 0, 1],
       [0, 0, 0, 1, 1, 4, 1],
       [0, 0, 0, 0, 1, 4, 1],
       [0, 0, 0, 0, 1, 4, 1],
       [0, 0, 0, 0, 1, 1, 1]]

# [16517,48],
s11 = [[1, 1, 1, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 4, 1],
       [1, 0, 2, 2, 1, 0, 1],
       [1, 0, 2, 0, 1, 3, 1],
       [1, 1, 2, 0, 1, 0, 1],
       [1, 4, 0, 0, 4, 0, 1],
       [1, 1, 1, 1, 1, 1, 1]]

# [22035,38],
s12 = [[0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1],
       [1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1],
       [1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 2, 1, 1, 1, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 1, 0, 1, 4, 0, 4, 1],
       [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1]]

# [26905,28],
s13 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 0, 0, 2, 0, 1],
       [1, 0, 2, 0, 0, 0, 0, 0, 4, 1],
       [1, 0, 3, 0, 0, 0, 0, 0, 2, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 4, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [41715,53],
s14 = [[0, 0, 1, 0, 0, 0, 0],
       [0, 2, 1, 4, 0, 0, 0],
       [0, 2, 0, 4, 0, 0, 0],
       [3, 2, 1, 1, 1, 0, 0],
       [0, 0, 1, 4, 0, 0, 0]]

# [48695,44],
s15 = [[1, 1, 1, 1, 1, 1, 1],
       [1, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 2, 2, 0, 1],
       [1, 0, 2, 0, 2, 3, 1],
       [1, 4, 4, 1, 1, 1, 1],
       [1, 4, 4, 1, 0, 0, 0],
       [1, 1, 1, 1, 0, 0, 0]]

# [91344,111],
s16 = [[1, 1, 1, 1, 1, 0, 0, 0],
       [1, 0, 0, 0, 1, 0, 0, 0],
       [1, 2, 1, 0, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 5, 0, 5, 0, 1],
       [1, 0, 5, 0, 1, 0, 1, 1],
       [1, 1, 1, 0, 3, 0, 1, 0],
       [0, 0, 1, 1, 1, 1, 1, 0]]

# [3301278,76],
# Warning: This problem is very hard and could be impossible to solve without a good heuristic!
s17 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 3, 0, 0, 1, 0, 0, 0, 4, 1],
       [1, 0, 2, 0, 2, 0, 0, 4, 4, 1],
       [1, 0, 2, 2, 2, 1, 1, 4, 4, 1],
       [1, 0, 0, 0, 0, 1, 1, 4, 4, 1],
       [1, 1, 1, 1, 1, 1, 0, 0, 0, 0]]

# [??,25],
s18 = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 4, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 4, 1, 0, 0, 0, 0]]

# [??,21],
s19 = [[0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],
       [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0],
       [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 4],
       [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 2, 0, 4, 1, 0, 0, 0]]


# Utility functions for printing states and moves.
# You do not need to understand any of the functions below this point.


# Helper function of prettyMoves
# Detect the move from state s --> s1
def detectDiff(s, s1):
    row, col = getKeeperPosition(s)
    row1, col1 = getKeeperPosition(s1)
    if (row1 == row + 1):
        return 'Down'
    if (row1 == row - 1):
        return 'Up'
    if (col1 == col + 1):
        return 'Right'
    if (col1 == col - 1):
        return 'Left'
    return 'fail'


# Translates a list of states into a list of moves
def prettyMoves(lists):
    initial = 0
    action = []
    for states in (lists):
        if (initial != 0):
            action.append(detectDiff(previous, states))
        initial = 1
        previous = states
    return action


# Print the content of the square to stdout.
def printsquare(v):
    if (v == blank):
        print(' ', end='')
    if (v == wall):
        print('#', end='')
    if (v == box):
        print('$', end='')
    if (v == keeper):
        print('@', end='')
    if (v == star):
        print('.', end='')
    if (v == boxstar):
        print('*', end='')
    if (v == keeperstar):
        print('+', end='')


# Print a state
def printstate(s):
    row = s.shape[0]
    col = s.shape[1]
    for i in range(row):
        for j in range(col):
            printsquare(s[i, j])
        print()


# Print a list of states with delay.
def printlists(lists):
    for states in (lists):
        printstate(states)
        print('\n')


# if __name__ == "__main__":
#     array_list = [s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15, s16, s17, s18, s19]
#     start_time = time.time()
#     for i in range(len(array_list)):
#         print("running s:", i+1)
#         sokoban(array_list[i], h505894780)
#     end_time = time.time()
#     print("time:", end_time - start_time)

if __name__ == "__main__":
    sokoban(s1, h0)

    sokoban(s2, h0)

    sokoban(s3, h0)

    sokoban(s4, h0)
